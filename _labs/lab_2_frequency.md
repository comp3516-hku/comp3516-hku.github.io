---
layout: lab
type: lab
date: 2025-02-09
title: 'Lab #2 Frequency'
# pdf: /static_files/assignments/asg.pdf
attachment: /static_files/lab_2_release.zip
# solutions: /static_files/assignments/asg_solutions.pdf
due_event: 
    type: due
    date: 2025-02-27T19:59:59
    description: 'Lab #2 due'
mathjax: true
---
# Lab 2 -- Frequency

In our previous lab, we guided you through the understanding and generation of various signals. You've already learned about amplitude and phase, two concepts easily identifiable in the  **temporal domain**. This clarity is because a signal can be conceptualized as a 'function' over time. However, there are two crucial aspects yet to be explored: frequency $f$ and sampling rate $f_s$. These concepts are integral to "frequency" properties and play a vital role in analyzing IoT data. In this lab, we aim to:

- Explain the physical meaning of frequency,
- Demonstrate coding method to determine a signal's frequency,
- Guide you in choosing an appropriate sampling rate.

### Example 1: Pure Tone Signal

We first start with pure tone signal. As said, pure tone signal can be mathematically expressed as
$$
s(t) = A \cdot \cos(2 \pi \cdot f \cdot t + \phi).
$$
where $A$ and $\phi$ are amplitude and phase, respectively. We have explored them in the previous lab. Now we see what the frequency would make a difference. 


```python
import numpy as np
from matplotlib import pyplot as plt

t = np.linspace(0, 0.3, 1000) # time 
f_1 = 10 # frequency
f_2 = 20 # frequency
s_1 = np.cos(2*np.pi*f_1*t) # signal
s_2 = np.cos(2*np.pi*f_2*t) # signal
plt.plot(t, s_1)
plt.plot(t, s_2)
plt.legend([f"f={f_1}Hz", f"f={f_2}Hz"], loc="upper right")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.xlim([0, 0.3])
plt.show()
```


    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_4_0.png)
    


We can see two waves are plotted, with different frequencies. For the blue line, the frequency is 10Hz, indicating the signal is repeating every 0.1s. In contrast, the orange line represents a signal with a frequency of 20Hz. A higher frequency implies a shorter period, meaning this signal completes its cycle more quickly. Specifically, at 20Hz, the signal completes one cycle every 0.05 seconds, as the period is 1/20s. This visual representation helps us understand how frequency affects the behavior of a wave. The higher the frequency, the more cycles the wave completes in a given time, leading to a 'tighter' wave pattern. Conversely, a lower frequency results in fewer cycles over the same duration, resulting in a 'looser' wave pattern.


From this simple demonstration, we gain a tangible understanding of frequency and how it reflects the repetition rate of a signal. This leads us to a pivotal question: How do we extract the frequency from the pure tone signal using programmable way?  That is, given $s(t)$ is a pure tone, how can we write a function `get_freq(s_t)` to directly get the frequency?

## Example 2: FFT of Pure Tone Signal

Obviously, for pure tone signals, the task is relatively straightforward as we can determine the frequency by measuring the intervals between peaks. Here, we introduce a more universal and robust way -- FFT (Fast Fourier Transform). 

At its core, the Fourier Transform is a mathematical technique that converts a signal from the temporal (time) domain to the frequency domain. If you're unfamiliar with the term 'domain', don't worry. We'll avoid complex mathematical definitions here. In simple terms, the temporal domain refers to representing the signal as a function of time ($t$), while the frequency domain represents the signal in terms of frequency ($f$). Again, we do not intend to involve the complex mathematical derivations here in this course. There is one thing that you should bear in mind: frequency domain shares the same information with time domain. In other word, we can use frequency domain to uncover the time domain without information loss (theorectically), and vice versa. 

Think of this transformation like telling a story in two different ways. One way is to tell the story as it unfolds over time. Alternatively, you can tell the same story by focusing on and categorizing its themes. The story remains the same; it's just interpreted differently depending on how it's presented. If the sequence of events is crucial, we use the first approach. If thematic elements are more important, we focus on the second perspective.

This analogy applies to signals as well. A signal is a physical and objective entity. To observe its variations over time, we use the temporal domain. To analyze its frequency components, which you'll find very useful, we switch to the frequency domain. Since temporal signals are more common in everyday observations, the Fourier Transform is the most convenient way to switch from the temporal to the frequency domain.



FFT (Fast Fourier Transform), as you can tell from the name, is a fast algorithm that accerlate the transformation computation on computers. Many software packages include FFT computations, such as `scipy`, `numpy`, `pytorch`, `tensorflow`, and others. Given its wide-ranging importance and applications, FFT has become an indispensable module in modern computational analysis software.

In this lab, we mainly introduce how we can utilize `scipy.fft`. Other packages have similar functions and usage, so the skills you learn here will be broadly applicable.


```python
from scipy.fft import fft, fftfreq
import numpy as np
from matplotlib import pyplot as plt

# Generate signals
fs = 2000 # sampling frequency
t = np.arange(0, 0.1, 1/fs) # time
f_1 = 200 # frequency
s_1 = np.cos(2*np.pi*f_1*t) # signal


fft_s_1 = fft(s_1)
fft_s_1_a = np.abs(fft_s_1)
fft_f_1 = fftfreq(len(t), t[1]-t[0]) 
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.plot(t, s_1)
plt.xlabel("Time [s]")
plt.ylabel("Amplitude (time domain)")


plt.subplot(122)
plt.stem(fft_f_1, fft_s_1_a)
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude (frequency domain)")

```




    Text(0, 0.5, 'Magnitude (frequency domain)')




    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_8_1.png)
    


The result of FFT is a complex signal. The magnitude of the FFT shows the contribution of each frequency component. We use `np.abs` to extract the magnitude. As you can see, the left figure is the time domain while the right figure shows the result of FFT. The x-axis of right figure is frequency. A key observation from the FFT is its symmetry, highlighted by two prominent peaks. This symmetry is characteristic of real-valued signals; essentially, the FFT output for such signals contains redundant information. The negative frequency components mirror their positive counterparts, providing no additional unique insights. To this end, in practice, we usually extract the positive frequency part as the frequency domain.


```python
n_fft = len(fft_s_1_a)
fft_s = fft_s_1_a[:n_fft//2]
fft_f = fft_f_1[:n_fft//2]
plt.figure(figsize=(5, 5))
plt.stem(fft_f, fft_s)
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude (frequency domain)")
```




    Text(0, 0.5, 'Magnitude (frequency domain)')




    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_10_1.png)
    


Now we can see an obvious peak. To get the frequency of this peak, we can use `find_peaks` function to locate the peak and get the frequency.


```python
from scipy.signal import find_peaks

x, _ = find_peaks(fft_s, threshold=10, prominence=1)
fft_f[x]
```




    array([200.])



As you can see, we use `find_peaks` to get the index of the peak. We use the index to acquire the real frequency, which is 200Hz. You can refer to its document for more information. Until now, we attempt to utilize `scipy.fft.fft` to get the frequency list of the pure tone signal. It is quite easy, since pure tone signal only has one frequency component.  

## Example 3: Music Tone

We give a more intuitive illustration of frequency through the example of music tones. In the realm of music, frequency serves as the backbone of what we perceive as pitch. Each musical note corresponds to a specific frequency, defined by the rate at which sound waves vibrate as they travel through the air. Consider a piano: when a key is struck, it causes the strings to vibrate, producing sound waves at particular frequencies. These frequencies are what our ears interpret as distinct musical notes. For example, the note A4, commonly used as a tuning reference, vibrates at 440 Hz. As we move up the musical scale, the frequency of each note increases, leading to higher pitches. This progression is illustrated in the sequence of notes from C4 to B4, each with its own unique frequency. C4, known as middle C, vibrates at approximately 261.63 Hz. Moving up, D4 (Re) is at 293.66 Hz, E4 (Mi) at 329.63 Hz, and so on, up to B4 (Si) at 493.88 Hz. This incremental increase in frequency translates to a corresponding rise in pitch. The concept of octaves further demonstrates this relationship: as we transition from one octave to the next, such as from A3 to A4, the frequency doubles. This phenomenon creates a sense of harmonic relation despite the increase in pitch, with A3 (220 Hz) and A4 (440 Hz) sounding consonant and connected. Thus, the frequency of musical notes not only defines their pitch but also forms the basis of the harmonic structure in music.


```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq

def generate_tone(frequency, duration, fs):
    """Generate a sine wave tone for a given frequency and duration."""
    t = np.linspace(0, duration, int(fs * duration), endpoint=False)
    return np.sin(2 * np.pi * frequency * t)

# Parameters
fs = 2000  # Sampling frequency (Hz)
duration = 1  # Duration of each note (seconds)

# Frequencies for C4 to b4
frequencies = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88]

# Generate tones for A1 to A7
tones = [generate_tone(f, duration, fs) for f in frequencies]

# Concatenate tones to form a signal
signal = np.concatenate(tones)

# Apply FFT to the concatenated signal
signal_fft = fft(signal)
frequencies_fft = fftfreq(len(signal), d=1/fs)

N = signal_fft.shape[0]
signal_fft = signal_fft[0:N//2]
frequencies_fft = frequencies_fft[0:N//2]

# Plot the FFT result
plt.plot(frequencies_fft, np.abs(signal_fft))
plt.title("FFT of C4 to B4 Tones")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
# plt.xlim(0, 4000)  # Adjust the x-axis range as needed
plt.show()
```


    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_16_0.png)
    



```python
from IPython.display import Audio
Audio(np.squeeze(signal), rate=fs)
```





<audio  controls="controls" >
    <source src="data:audio/wav;base64,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" type="audio/wav" />
    Your browser does not support the audio element.
</audio>




For pure tone signals, the task is relatively straightforward as we can determine the frequency by measuring the intervals between peaks. However, in the real world, signals are often not pure tones and may even be aperiodic. Yet, intuitively, we know that these complicated signals also embody frequency characteristics. The challenge, therefore, lies in uncovering the frequencies within these more intricate and varied signals.

## Example 4: FFT of Pulse Signal

First considering a periodic pulse signal, defined as below:
\begin{equation*}
\hat{s(t)} \equiv p_\tau(t)= \begin{cases}0 & \text { for }-\tau_0 / 2<t<-\tau / 2 \\ 1 & \text { for }-\tau / 2 \leq t \leq \tau / 2 \\ 0 & \text { for } \tau / 2<t \leq \tau_0 / 2\end{cases},
\end{equation*}
Here we let $\tau_0=4s$ and $\tau=2s$.


```python
# Set parameters for the pulse signal
tau = 2.0 # Pulse width
tau_0 = 4.0  # Total period of the signal

fs = 100  # Sampling frequency
t = np.arange(-1.5 * tau_0, 1.5 * tau_0, 1/fs)  # Time vector

def p_tau(t, tau, tau_0):
    """
    Defines the pulse signal p_tau(t). 
    It will repeat every tau_0 seconds.

    Parameters:
    t (numpy array): Time array.
    tau (float): Pulse width.
    tau_0 (float): Total period of the signal.

    Returns:
    numpy array: The pulse signal values.
    """
    period = np.floor((t + tau_0 / 2) / tau_0) * tau_0
    t_adjusted = t - period
    return np.where(np.abs(t_adjusted) < tau / 2, 1, 0)

s_t = p_tau(t, tau, tau_0)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(t, s_t, label="$\hat{s(t)}$",drawstyle='steps-post')
plt.xlabel("Time (t)")
plt.ylabel("Amplitude")
plt.title("Pulse Signal $\hat{s(t)}$")
plt.annotate('$-\\tau_0/2$', xy=(-tau_0/2, 0), xytext=(-tau_0/2, -0.1), ha='center', arrowprops=dict(facecolor='black', arrowstyle='->'))
plt.annotate('$-\\tau/2$', xy=(-tau/2, 0), xytext=(-tau/2, -0.1), ha='center', arrowprops=dict(facecolor='black', arrowstyle='->'))
plt.annotate('$\\tau/2$', xy=(tau/2, 0), xytext=(tau/2, -0.1), ha='center', arrowprops=dict(facecolor='black', arrowstyle='->'))
plt.annotate('$\\tau_0/2$', xy=(tau_0/2, 0), xytext=(tau_0/2, -0.1), ha='center', arrowprops=dict(facecolor='black', arrowstyle='->'))
plt.ylim(-0.2, 1.1)
plt.grid(True)


s_f = fft(s_t)
s_f_len = len(s_f)
s_f_freq = fftfreq(s_f_len, d=1/fs)
s_f = s_f[0:s_f_len//2]
s_f_freq = s_f_freq[0:s_f_len//2]
s_f = np.abs(s_f)
plt.subplot(1, 2, 2)
plt.stem(s_f_freq, s_f, label="$S(f)$")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.title("Frequency Domain of PeriodicPulse Signal")
plt.grid(True)
```


    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_21_0.png)
    



```python
from scipy.signal import find_peaks
s_f_100, s_f_freq_100 = s_f[:100], s_f_freq[:100]
x_peaks, _ = find_peaks(s_f_100, threshold=0.5, prominence=0.1)

plt.stem(s_f_freq_100, s_f_100, linefmt='C0-', markerfmt='C0o', basefmt='C0-', label='$S(f)$')
plt.plot(s_f_freq_100[x_peaks], s_f_100[x_peaks], 'x', label="Peaks", color="red")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.title("Frequency Domain of Periodic Pulse Signal")
plt.grid(True)

print(f"Peaks at {s_f_freq_100[x_peaks]} Hz")
```

    Peaks at [0.25 0.75 1.25 1.75 2.25 2.75 3.25 3.75 4.25 4.75 5.25 5.75 6.25 6.75
     7.25 7.75] Hz



    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_22_1.png)
    


We can see the first peak represents 0.25Hz, which is the period of the periodic pulse wave. And the remaining are the harmonics. These are all **frequency components** of $s(t)$. The key idea of Fourier Transform is to turn every signal as an aggregation of pure tones with different amplitudes, phase and frequencies. Essentially, the Fourier Transform seeks to approximate the original signal function as a sum of sinusoidal waves, akin to how the Taylor Expansion represents a function as a sum of polynomials.  Frequency is not confined solely to periodic signals with repeating cycles; in fact, any physical signal possessing finite energy can be decomposed into a series of pure tones. These tones differ in their amplitudes, phases, and frequencies. The frequencies of these pure tones constitute the frequency components of the original signal. In other word, we can apply FFT on **both periodic and non-periodic** signals.

Now we consider a non-periodic pulse wave.


```python
# Set parameters for the pulse signal
tau = 2.0 # Pulse width

fs = 100  # Sampling frequency
t = np.arange(-6, 6, 1/fs)  # Time vector

def p_tau(t, tau):
    """
    Defines the pulse signal p_tau(t). 

    Parameters:
    t (numpy array): Time array.
    tau (float): Pulse width.

    Returns:
    numpy array: The pulse signal values.
    """
    return np.where(np.abs(t) < tau / 2, 1, 0)

s_t = p_tau(t, tau)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(t, s_t, label="${s(t)}$",drawstyle='steps-post')
plt.xlabel("Time (t)")
plt.ylabel("Amplitude")
plt.title("Pulse Signal ${s(t)}$")
plt.annotate('$-\\tau/2$', xy=(-tau/2, 0), xytext=(-tau/2, -0.1), ha='center', arrowprops=dict(facecolor='black', arrowstyle='->'))
plt.annotate('$\\tau/2$', xy=(tau/2, 0), xytext=(tau/2, -0.1), ha='center', arrowprops=dict(facecolor='black', arrowstyle='->'))
plt.ylim(-0.2, 1.1)
plt.grid(True)


s_f = fft(s_t)
s_f_len = len(s_f)
s_f_freq = fftfreq(s_f_len, d=1/fs)
s_f = s_f[0:s_f_len//2]
s_f_freq = s_f_freq[0:s_f_len//2]
s_f = np.abs(s_f)
plt.subplot(1, 2, 2)
plt.plot(s_f_freq, s_f, label="$S(f)$")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.title("Frequency Domain of PeriodicPulse Signal")
plt.grid(True)
```


    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_24_0.png)
    



```python
from scipy.signal import find_peaks
s_f_100, s_f_freq_100 = s_f[:100], s_f_freq[:100]
x_peaks, _ = find_peaks(s_f_100, threshold=0.5, prominence=0.1)

plt.stem(s_f_freq_100, s_f_100, linefmt='C0-', markerfmt='C0o', basefmt='C0-', label='$S(f)$')
plt.plot(s_f_freq_100, s_f_100, "--")
plt.plot(s_f_freq_100[x_peaks], s_f_100[x_peaks], 'x', label="Peaks", color="red")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.title("Frequency Domain of Pulse Signal")
plt.grid(True)

print(f"Peaks at {s_f_freq_100[x_peaks]} Hz")
```

    Peaks at [0.75 1.25 1.75 2.25 2.75 3.25 3.75 4.25 4.75 5.25 5.75 6.25 6.75 7.25
     7.75] Hz



    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_25_1.png)
    


Compared to previous periodic pulse signal, we can tell from the frequency components that they are the same as that of periodic signal, excluding the period.  Notably, the frequency spectrum of the non-periodic signal appears denser Actually, the FFT of non-periodic signal will result is continous frequency spectrum. Conversely, the FFtT of periodic signal leads to discrete frequency spectrum. These are two interesting dualities.

By now, I hope you have learned how to use `scipy.fft.fft` for frequency analysis. The process begins with performing an FFT on the time-domain signals. After obtaining the FFT results, we typically consider only half of the output, as it contains the useful information we need. The other half is usually symmetric and redundant for our purposes. In most of our labs and tasks going forward, unless specified otherwise, we will refer to the magnitude of the FFT output as the frequency spectrum. Below, we will discuss some parameters that will affect the result of FFT.

## Example 5: Sampling

Previously we set up the sampling rate `fs`($f_s$) for you, as well as the duration $T$. Given these two parameters, we can acquire the number of samples $N$:
$$
N = T \cdot f_s.
$$

This is vital, since it bridges a continous variable $T$ with a discrete $N$. As discussed in Lab 1, signals can be classified into analog and digital types. In the realm of computing, we predominantly process digital signals. The transformation of an analog signal into a digital one typically involves an essential process known as sampling. There are several methods for sampling, but in this course, we focus on the simplest form: even sampling.  The sampling rate `fs` refers to how many samples we acquire in one second. Intuitively, to capture higher frequency components in a signal, a higher sampling rate is required. Consider the analogy of using a camera to capture images of a spinning wheel: if the sampling rate is too low, it becomes challenging to observe the wheel's rotation. Consequently, there should be a **minimum threshold** for the sampling rate that can fully capture the signal's frequency range. This is where the Nyquist theorem comes into play. It states that the sampling rate should be at least **twice** the highest frequency component in the signal to accurately capture all the information (avoid aliasing),
$$
f_s \ge 2 \cdot f_{\max}.
$$

This concept is also evident in the FFT spectrum. By definition, the FFT spectrum repeats at every $f_s$.  Therefore, the output of `scipy.fft.fftfreq` typically displays a frequency range from $[0, f_s]$. As discussed above, only half of the FFT spectrum contains useful information, limiting the useful frequency band to $[0, \dfrac{f_s}{2}]$ Hz. Thus, to ensure accurate representation, it must be larger than twice the largest frequency component $f_{\max}$. We will demonstrate this through practical coding examples.



```python
import numpy as np
from matplotlib import pyplot as plt
from scipy.fft import fft, fftfreq
from scipy.signal import find_peaks


fs_1 = 30  # Sampling frequency
fs_2 = 8

f = 5

t_1 = np.arange(-2, 2, 1/fs_1)  # Time vector
t_2 = np.arange(-2, 2, 1/fs_2)  # Time vector

s_t_1 = np.cos(2*np.pi*f*t_1)
s_t_2 = np.cos(2*np.pi*f*t_2)

plt.figure(figsize=(12, 12))
plt.subplot(2, 2, 1)
plt.plot(t_1, s_t_1, label=f"$s_1(t), f_s={fs_1}Hz$")
plt.xlabel("Time (t)")
plt.ylabel("Amplitude")
plt.title("$s_1(t)$")
plt.legend(loc="upper right")

plt.subplot(2, 2, 2)
plt.plot(t_2, s_t_2, label=f"$s_2(t), f_s={fs_2}Hz$")
plt.xlabel("Time (t)")
plt.ylabel("Amplitude")
plt.title("$s_2(t)$")
plt.legend(loc="upper right")

s_f_1 = fft(s_t_1)
s_f_1_len = len(s_f_1)
s_f_1_freq = fftfreq(s_f_1_len, d=1/fs_1)
s_f_1 = s_f_1[0:s_f_1_len//2]
s_f_1_freq = s_f_1_freq[0:s_f_1_len//2]
s_f_1 = np.abs(s_f_1)

s_f_2 = fft(s_t_2)
s_f_2_len = len(s_f_2)
s_f_2_freq = fftfreq(s_f_2_len, d=1/fs_2)
s_f_2 = s_f_2[0:s_f_2_len//2]
s_f_2_freq = s_f_2_freq[0:s_f_2_len//2]
s_f_2 = np.abs(s_f_2)

plt.subplot(2, 2, 3)
plt.stem(s_f_1_freq, s_f_1, label=f"$S_1(f), f_s={fs_1}Hz$")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.title("$S_1(f)$")
plt.legend(loc="upper right")

plt.subplot(2, 2, 4)
plt.stem(s_f_2_freq, s_f_2, label=f"$S_2(f), f_s={fs_2}Hz$")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.title("$S_2(f)$")
plt.legend(loc="upper left")

```




    <matplotlib.legend.Legend at 0x7efb61f05be0>




    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_30_1.png)
    


As shown above, we plot two signal of the same frequency $f=5$ with different sampling frequencies. The left part ($s_1(t)$ and $S_1(f)$) is sampled at 30Hz. This sampling rate is greater than twice the maximum frequency present in the signal (which, in this case, has only one frequency component). As a result, both the temporal and frequency domains are well-represented. The frequency of 5 Hz is clearly observable in $S_1(f)$. 

Conversely, the right part ($s_2(t)$ and $S_2(f)$) is sampled at 8Hz. This rate is insufficient for the given signal frequency, leading to aliasing, which manifests as a distortion in the temporal signal. Moreover, the frequency displayed in the FFT is incorrect due to this under-sampling. And the frequency shown on FFT is not right (You can think about why this frequency occurs.). This example effectively demonstrates how the choice of sampling rate can significantly impact signal representation in both the time and frequency domains.

Alternatively, the sampling rate can be seen as the reciprocal of temporal *resolution* of the signal. The resolution means we can distinguish clearly between two samples, which is
$$
\Delta t = \frac{1}{f_s}.
$$
For example, if $f_s=10$Hz, it means 10 samples is generated within one second. The time difference between these samples is $1/10=0.1$s. In some textbook, you may encounter a word "bin" to denote the interval. We can say the time bin of the signal is 0.1s. At the same time, the FFT spectrum is also discrete. How can we calculate the frequency resolution (frequency resolution)? The total length of the computed FFT is $\dfrac{N_{\text{FFT}}}{2}$, and there are overall $\dfrac{f_s}{2}$ frequencies (whether divide 2 does not matter here). Therefore, the distance between adjancent frequency is 
$$
\Delta f_{\text{FFT}} = \frac{f_s}{N_{\text{FFT}}},
$$
which is the frequency resolution. Note that $N_{\text{FFT}}$ is the length of the FFT. It can be different from the length of the signal. Sometimes we may empirically set $N$ to the closest number that is power of 2, which is best for FFT algorithm. If we use the FFT length $N_{\text{FFT}} > N$, where $N$ is the length of the signal, 0s will be padding after the original signal to meet the desired length. We call this operartion as zero padding. Note that though zero padding can create more points in the FFT spectrum, thus making more fine-grained resolution on the FFT graph, it does not make a real difference! Here, to avoid confusion, we denote the above frequency resolution $\Delta f_{\text{FFT}}$ as "FFT resolution". Zero padding in the temporal domain will result in interpolation in the frequency domain. While zero padding can refine the FFT resolution and make the frequency spectrum appear more detailed, it does not increase the ability to distinguish new frequencies. This ability is physically restrained by the "real frequency resolution", which is
$$
\Delta f = \frac{f_s}{N} = \frac{1}{T},
$$
where $N$ is the length of the signal. In other word, the ability to distinguish adjacent frequency is limited by both sampling rate $f_s$, and signal length $N$. If this result cannot do, then zero padding can not do either. For example, if $fs/N = 2$, that means the minimum frequency difference it can tell from the FFt graph is 2Hz. It is definitely unable to analyze a signal with frequency 10Hz and 11Hz. 


```python
import numpy as np
from matplotlib import pyplot as plt
from scipy.fft import fft, fftfreq
from scipy.signal import find_peaks


fs = 100
N = 1000
t = np.arange(0, N/fs, 1/fs)  # Time vector
f_1 = 10
f_2 = 20
s_t = np.cos(2*np.pi*f_1*t) + np.cos(2*np.pi*f_2*t)

s_f = fft(s_t)
s_f_len = len(s_f)
s_f_freq = fftfreq(s_f_len, d=1/fs)
s_f = s_f[0:s_f_len//2]
s_f_freq = s_f_freq[0:s_f_len//2]
s_f = np.abs(s_f)

s_f_pad = fft(s_t, n=2048) # padding to 2048 points
s_f_pad_len = len(s_f_pad)
s_f_pad_freq = fftfreq(s_f_pad_len, d=1/fs)
s_f_pad = s_f_pad[0:s_f_pad_len//2]
s_f_pad_freq = s_f_pad_freq[0:s_f_pad_len//2]
s_f_pad = np.abs(s_f_pad)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.stem(s_f_freq, s_f, label="$S(f)$")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.title("Frequency Domain of Signal")
plt.grid(True)

plt.subplot(1, 2, 2)
plt.stem(s_f_pad_freq, s_f_pad, label="$S(f)$")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.title("Frequency Domain of Signal (with padding)")
plt.grid(True)
```


    
![png](../static_files/lab_2_frequency_files/lab_2_frequency_32_0.png)
    


As you can see, no matter whether we pad zeros, it makes no difference to distinguish the two frequencies 10Hz and 11Hz. 

In summary, the choice of sampling rate is critical in accurately capturing and analyzing a signal's frequency components. It influences the temporal and frequency resolution, affecting both the time-domain representation and the FFT spectrum. Understanding these principles is key in signal processing, especially when interpreting FFT results and considering the effects of sampling and zero padding on frequency analysis.

## Programming task

## Task 2-1: Apply FFT (10 points)

**You are required to implement the functions in `task_2_1.py`**.

Compute the frequency spectrum of the following signals. You are supposed to implement `apply_fft_pt()` for the following two signals, respectively.

The sampling rate `self.fs` is 2000 Hz. The time range is $-1 \le t < 1s$. In this task, you are required to return the frequency spectrum, i.e. frequency axis and magnitude. Also, you are expected to perform $N$-point FFT, where $N$ is the length of the signal.

The signal is defined as follows:
$$
s(t) = 2.025 \cdot \cos(2 \pi \cdot 20.25 \cdot t + \pi/3)
$$

You should return the frequency axis and magnitude of the signal.

> Run `python check.py --task 1` to evaluate your implementation. Note that passing the test does not guarantee full points. The final grading will be based on the correctness of your implementation.


## Task 2-2: Get Frequency from FFT I (30 points)

**You are required to implement the functions in `task_2_2.py`**.

In this task, you are now given multiple files. These files contain signals that we want you to perform frequency analysis on. Your task is to implement `get_freq_spt()`, `get_bw_chirp()`, `get_heart_rate()` and `get_breathe_rate()`, respectively.

1. `task_2_2_1.pickle`: The sum of several pure tone signals. The sampling rate is 16000 Hz. You need to return 3 primary frequency components in descending order.
   
2. `task_2_2_2.pickle`: A chirp signal. The sampling rate is 16000 Hz. In this task, your task is to return the bandwidth of the chirp signal.
   
3. `task_2_2_3.pickle`: A clip of ECG (electrocardiogram) signal. The sampling rate is 100 Hz. Your task is to uncover the heart rate from ECG. Heartbeat is a periodic event, and the heart rate is the frequency that the heart beats.  The heart rate of this participant is between 60 - 90 BPM (Beat Per Second). You should return the heart rate in BPM. 


  

**Note:**

- For task 2_2_3, you are recommended to only focus on those peaks whose corresponding frequencies lie in the reasonable range of your task, i.e. heart rate range or breathing rate range.
- For tasks 2_2_2 and 2_2_3, your results will be evaluated within certain thresholds to determine their accuracy. We will use two thresholds to assess your answers: one for correct answers and another for incorrect ones. Answers falling between these thresholds will have their grades adjusted proportionally based on their proximity to the Ground Truth (GT).
  - task 2_2_2: A response within $\pm 10\%$ of the GT will be considered correct. Answers deviating by more than $\pm 15\%$ from the GT will be marked incorrect.
  - task 2_2_3: The floating ratio is $\pm 5\%$ for a correct answer and $\pm 8\%$ for an incorrect one.

> Run `python check.py --task 2` to evaluate your implementation. Note that passing the test does not guarantee full points. The final grading will be based on the correctness of your implementation.



## Task 2-3: Get Frequency from FFT II (20 points)

**You are required to implement the functions in `task_2_3.py`**.

Get the frequency list of the following signals. The time range is $\left.\left[-\dfrac{N}{2\cdot f_s}, -\dfrac{N}{2\cdot f_s}\right.\right)$s, where $f_s$ is the sampling rate and $N$ is the number of samples. We perform $N$-point FFT. 

In this task, you have to first set proper `fs` and `N`, then perform FFT and get the frequency list.

> Hint: The answer is not uninquely determined. You can consider the frequency reolution and the Nyquist frequency.

> **2-3-1**: Implement `get_freq_1()` to get the frequency list of signal function:

$$
s(t) = \cos(2 \pi \cdot 50.99 \cdot t) + \cos(2 \pi \cdot 51 \cdot t) + \sin(2 \pi \cdot 51.02 \cdot t)
$$

> **2-3-2**: Implement `get_freq_2()` to get the frequency list of signal function:

$$
s(t) = \cos(2 \pi \cdot 51.2 \cdot t) + \sin(2 \pi \cdot 1000.6 \cdot t) + \cos(2 \pi \cdot 2000 \cdot t)
$$

You have to return `fs`, `N`, and `f`, where `f` is the frequency list.

## Task 2-4: FMCW Radar (40 points)

**You are required to implement the functions in `task_2_4.py`**.

In this task, you will gain experience with a mmWave radar system. 

Usually, a typical mmWave radar employs a frequency-modulated continuous-wave (FMCW, a.k.a chirp) signal to detect the target. The radar system transmits a continuous wave signal with a frequency that linearly increases over time. The radar system then receives the reflected signal from the target. By comparing the transmitted and received signals, the radar system can determine the distance and angle of the target.

We define the FMCW signal as follows:
$$
s(t) = \exp\left(j \cdot 2\pi \cdot (f_s \cdot + \dfrac{B}{2 \cdot T} \cdot t)\cdot t\right)
$$
where $f_s$ is the starting frequency,  and $\phi$ is the phase offset. We omit the amplitude item here. $B$ is the bandwidth of the chirp signal, and $T$ is the duration of the chirp signal. These parameters are set as follows:
```python
# Radar parameters
c = 3e8           # Speed of light (m/s)
fc = 1e9          # Carrier frequency (Hz) 
B = 1.5e9         # Bandwidth (Hz)
T = 100e-6        # Chirp duration (s)
Fs = 2e6          # Sampling rate (Hz)
NUM_ANTENNAS = 4  # Number of antennas
```


> **Checkpoint 1:** Generate the transmitted signal (5 points).

You are required to implement `generate_transmitted_signal()` to generate the transmitted signal. You should return the transmitted signal. Please note that you should return the chirp signal in the complex form.

The transmitted signal will then transverse and be reflected off the object. We then multiply the received signal with the transmitted signal to get the IF signal, which is given by

$$
s_{\text{IF}}(t) = s(t) \cdot r^*(t)
$$
where $r(t)$ is the received signal. `*` denotes the complex conjugate.

> **Checkpoint 2:** Compute the IF signal (5 points).

You are required to implement `compute_if_signal()` to generate the IF signal. You should return the IF signal and the time axis.

Then we will estimate the distance of the target by analyzing the IF signal. As discussed in the lecture, the temporal difference is tiny and can hardly be observed directly. Alternatively, we can analyze the frequency difference between the transmitted and received signals. The relationship between the frequency difference and the distance is given by
$$
d = \frac{c \cdot f_d \cdot T}{2 \cdot B}
$$
where $f_d$ is the frequency difference between the transmitted and received signals, and $c$ is the speed of light.
To get the frequency difference, we can perform FFT on the IF signal.

> **Checkpoint 3:** Estimate the distance (15 points).

You are required to implement `estimate_distance()` to estimate the distance of the targets. You should return the distance of each target in ascending order.

Additioally, you are required to return the `range_fft` and `range_bins`. `range_fft` is the FFT result of the IF signal, and `range_bins` is the corresponding range bins in meters. 

> Hint: You can expect to see two peaks in the range-FFT. We showcase an illustration here, where the x-axis is the range bins and the y-axis is the magnitude of the FFT result.
![range_fft](../static_files/range_fft.png)

Localizing distance is not enough. We also need to estimate the angle of the target. The angle can be estimated by analyzing the phase difference between the transmitted and received signals. Simply put, the AoA can be estimated by
$$
\theta = \arcsin\left(\frac{\Delta \phi}{2\pi \cdot f_c \cdot T}\right)
$$

> **Checkpoint 4:** Estimate the AoA (15 points).

You are required to implement `estimate_AoA()` to estimate the angle of the target. You should return the angle of the target corresponding to the distance. The angles should be in degrees and kept one decimal place. The key of the dictionary is the distance of the target, and the value is the angle of the target.

> Hint: You will need the results from checkpoint 3 to localize the range bins. It is better to use 2048-point FFT to get the AoA on each range bin.

> To get the right answer, ~10 lines of code are enough.


> Run `python check.py --task 4` to evaluate your implementation. Note that passing the test does not guarantee full points. The final grading will be based on the correctness of your implementation.

## How to submit

**Please run `python check.py --uid <YOUR_UID>` before submitting.** This script performs automated tests on the examples provided in the docstrings. Failing these tests indicates potential critical issues in your code. Strive to resolve these problems. After that, it will create a zip file named after your `uid`. Make sure you enter the right `uid`. 

Please be aware that successfully passing the checker is **NOT** a definitive indicator that you have met all test requirements. Generally, the checker is designed to assess **the format** of your output, rather than its content. Therefore, it remains your responsibility to thoroughly verify the reliability and accuracy of your code. 

It's important to avoid changing the names of any files, including both the zip file and the program files contained within. Altering file names can lead to grading errors. Ensure that all file names remain as they are to facilitate accurate assessment of your work.

Your submission to **Moodle** should consist solely of the **generated `*.zip` file**. It is your responsibility to double check whether your submitted zip file includes your latest work. 

